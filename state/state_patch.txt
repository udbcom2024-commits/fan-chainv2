	// 2. ã€ç­¾åéªŒè¯ã€‘éªŒè¯äº¤æ˜“ç­¾åï¼ˆé˜²æ­¢ä¼ªé€ ï¼‰
	if err := tx.Validate(); err != nil {
		return fmt.Errorf("invalid transaction: %v", err)
	}

	// 2.1. éªŒè¯ç­¾åæœ‰æ•ˆæ€§
	signData := tx.SignData()
	if !crypto.Verify(tx.PublicKey, signData, tx.Signature) {
		log.Printf("ğŸš¨ æ£€æµ‹åˆ°ä¼ªé€ ç­¾åï¼From: %s, TxHash: %s", tx.From, tx.Hash().String())
		// ä¼ªé€ ç­¾åæ˜¯ä¸¥é‡æ”»å‡»ï¼Œæ²¡æ”¶æ‰€æœ‰èµ„é‡‘
		if err := sm.confiscateAllFunds(tx.From, "ä¼ªé€ äº¤æ˜“ç­¾å"); err != nil {
			log.Printf("æ²¡æ”¶èµ„é‡‘å¤±è´¥: %v", err)
		}
		return fmt.Errorf("ğŸš¨ ç­¾åéªŒè¯å¤±è´¥ï¼šä¼ªé€ ç­¾åï¼Œæ‰€æœ‰èµ„é‡‘å·²æ²¡æ”¶")
	}

	// 2.2. éªŒè¯å…¬é’¥æ˜¯å¦åŒ¹é…å‘é€è€…åœ°å€
	derivedAddress, err := core.AddressFromPublicKey(tx.PublicKey)
	if err != nil {
		return fmt.Errorf("æ— æ³•ä»å…¬é’¥ç”Ÿæˆåœ°å€: %v", err)
	}
	if derivedAddress != tx.From {
		log.Printf("ğŸš¨ æ£€æµ‹åˆ°åœ°å€ä¼ªé€ ï¼Claimed: %s, Actual: %s", tx.From, derivedAddress)
		// åœ°å€ä¼ªé€ æ˜¯ä¸¥é‡æ”»å‡»ï¼Œæ²¡æ”¶æ‰€æœ‰èµ„é‡‘
		if err := sm.confiscateAllFunds(derivedAddress, fmt.Sprintf("ä¼ªé€ å‘é€è€…åœ°å€ (claimed=%s)", tx.From)); err != nil {
			log.Printf("æ²¡æ”¶èµ„é‡‘å¤±è´¥: %v", err)
		}
		return fmt.Errorf("ğŸš¨ åœ°å€éªŒè¯å¤±è´¥ï¼šå…¬é’¥ä¸åŒ¹é…å‘é€åœ°å€")
	}
